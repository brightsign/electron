From a7f977ff3c676c4ed3dacbdb8d5ee2644689e407 Mon Sep 17 00:00:00 2001
From: Caner Altinbasak <cal@brightsign.biz>
Date: Tue, 23 May 2023 11:15:31 +0100
Subject: [PATCH] brightsign: Add support for Brightsign video player

Adds compile and runtime options for Brightsign video player, which links
with libvid.
---
 build/config/brightsign_build.gni             |   5 +
 .../renderer_host/render_process_host_impl.cc |   1 +
 media/base/media_switches.cc                  |   5 +
 media/base/media_switches.h                   |   4 +
 media/media_options.gni                       |   4 +
 .../blink/renderer/platform/media/BUILD.gn    |  23 +
 .../media/brightsign/video_player_proxy.cc    | 135 ++++
 .../media/brightsign/video_player_proxy.h     |  50 ++
 .../brightsign/web_media_player_brightsign.cc | 755 ++++++++++++++++++
 .../brightsign/web_media_player_brightsign.h  | 246 ++++++
 .../media/web_media_player_builder.cc         |  45 +-
 11 files changed, 1258 insertions(+), 15 deletions(-)
 create mode 100644 build/config/brightsign_build.gni
 create mode 100644 third_party/blink/renderer/platform/media/brightsign/video_player_proxy.cc
 create mode 100644 third_party/blink/renderer/platform/media/brightsign/video_player_proxy.h
 create mode 100644 third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.cc
 create mode 100644 third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h

diff --git a/build/config/brightsign_build.gni b/build/config/brightsign_build.gni
new file mode 100644
index 0000000000000..5a3085210677e
--- /dev/null
+++ b/build/config/brightsign_build.gni
@@ -0,0 +1,5 @@
+declare_args() {
+  # Defines if BrightSign specific Chromium features are enabled
+  is_brightsign = false
+}
+
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 7249e2ff8d4ab..750f54fe0a58c 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3406,6 +3406,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kTimeZoneForTesting,
     switches::kTouchEventFeatureDetection,
     switches::kTraceToConsole,
+    switches::kUseBrightsignMediaPlayer,
     switches::kUseFakeCodecForPeerConnection,
     switches::kUseFakeUIForMediaStream,
     switches::kUseMobileUserAgent,
diff --git a/media/base/media_switches.cc b/media/base/media_switches.cc
index 72886a1e25b54..849c216c18624 100644
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -18,6 +18,11 @@
 
 namespace switches {
 
+const char kUseBrightsignMediaPlayer[] = "use-brightsign-media-player";
+
+// VideoServerFactory name
+const char kVideoServerFactoryName[] = "video-server-factory-name";
+
 // Allow users to specify a custom buffer size for debugging purpose.
 const char kAudioBufferSize[] = "audio-buffer-size";
 
diff --git a/media/base/media_switches.h b/media/base/media_switches.h
index 8af79cb1c1526..e469a6217e144 100644
--- a/media/base/media_switches.h
+++ b/media/base/media_switches.h
@@ -22,6 +22,10 @@ class CommandLine;
 
 namespace switches {
 
+MEDIA_EXPORT extern const char kUseBrightsignMediaPlayer[];
+
+MEDIA_EXPORT extern const char kVideoServerFactoryName[];
+
 MEDIA_EXPORT extern const char kAudioBufferSize[];
 
 #if BUILDFLAG(ENABLE_PASSTHROUGH_AUDIO_CODECS)
diff --git a/media/media_options.gni b/media/media_options.gni
index f4696a2026306..92b91abe1d18e 100644
--- a/media/media_options.gni
+++ b/media/media_options.gni
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/brightsign_build.gni")
 import("//build/config/chrome_build.gni")
 import("//build/config/chromecast_build.gni")
 import("//build/config/chromeos/args.gni")
@@ -102,6 +103,9 @@ declare_args() {
       proprietary_codecs &&
       (use_fuzzing_engine || use_chromeos_protected_media || is_win || is_mac ||
        is_android || is_linux)
+
+  # Enable Brightsign Media Player
+  enable_brightsign_media_player = is_brightsign
 }
 
 # Use another declare_args() to allow dependence on args defined above.
diff --git a/third_party/blink/renderer/platform/media/BUILD.gn b/third_party/blink/renderer/platform/media/BUILD.gn
index 71f2cb5d8c38a..2b3096ed5ba41 100644
--- a/third_party/blink/renderer/platform/media/BUILD.gn
+++ b/third_party/blink/renderer/platform/media/BUILD.gn
@@ -2,8 +2,10 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/linux/pkg_config.gni")
 import("//media/media_options.gni")
 
+
 # TODO(https://crbug.com/1198341): use blink_platform_sources once the code is
 # ported to Blink code conventions.
 component("media") {
@@ -104,6 +106,27 @@ component("media") {
       "//third_party/blink/public/strings:strings_grit",
     ]
   }
+
+  if (enable_brightsign_media_player) {
+    defines = ["ENABLE_BRIGHTSIGN_MEDIA_PLAYER"]
+    sources += [
+      "brightsign/video_player_proxy.cc",
+      "brightsign/video_player_proxy.h",
+      "brightsign/web_media_player_brightsign.cc",
+      "brightsign/web_media_player_brightsign.h",
+    ]
+    configs += [ ":vid" ]
+    configs += [ ":bvp" ]
+  }
+}
+
+if (enable_brightsign_media_player) {
+    pkg_config("vid") {
+      packages = [ "vid_wrapper" ]
+    }
+    pkg_config("bvp") {
+      packages = [ "bvp" ]
+    }
 }
 
 source_set("unit_tests") {
diff --git a/third_party/blink/renderer/platform/media/brightsign/video_player_proxy.cc b/third_party/blink/renderer/platform/media/brightsign/video_player_proxy.cc
new file mode 100644
index 0000000000000..02ba79772dd11
--- /dev/null
+++ b/third_party/blink/renderer/platform/media/brightsign/video_player_proxy.cc
@@ -0,0 +1,135 @@
+#include "third_party/blink/renderer/platform/media/brightsign/video_player_proxy.h"
+
+#include "base/bind.h"
+#include "base/task/single_thread_task_runner.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h"
+
+using namespace brightsign;
+
+#define BS_DEBUG(...)                 \
+  do {                                \
+    if (0)                            \
+      fprintf(stderr, ##__VA_ARGS__); \
+  } while (0)
+
+namespace blink {
+
+VidPlayerListenerProxy::VidPlayerListenerProxy(
+    base::WeakPtr<WebMediaPlayerBrightsign> web_media_player,
+    blink::WebLocalFrame* frame)
+    : main_task_runner_(
+          frame->GetTaskRunner(blink::TaskType::kMediaElementEvent)),
+      web_media_player_(web_media_player)
+
+{}
+
+VidPlayerListenerProxy::~VidPlayerListenerProxy() {}
+
+void VidPlayerListenerProxy::ErrorCallback(enum VidPlayerErrorCode error_code,
+                                     const char* message) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::ErrorCallback,
+                                web_media_player_, error_code, message));
+}
+
+void VidPlayerListenerProxy::PlaybackStartedCallback() {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::PlaybackStartedCallback,
+                                web_media_player_));
+}
+
+void VidPlayerListenerProxy::PlaybackCompletedCallback() {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::PlaybackCompletedCallback,
+                                web_media_player_));
+}
+
+void VidPlayerListenerProxy::LoadCallback(
+    int64_t current_time, const StringMapVector& video_tracks,const StringMapVector& audio_tracks, const StringMapVector& text_tracks){
+
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&WebMediaPlayerBrightsign::LoadCallback, web_media_player_,
+                     current_time, video_tracks, audio_tracks, text_tracks));
+}
+
+void VidPlayerListenerProxy::SeekCompletedCallback(
+    int64_t current_time) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::SeekCompletedCallback,
+                                web_media_player_, current_time));
+}
+
+void VidPlayerListenerProxy::VideoSizeChangedCallback(uint32_t width,
+                                                uint32_t height,
+                                                bool video_on_graphics) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&WebMediaPlayerBrightsign::VideoSizeChangedCallback,
+                     web_media_player_, width, height, video_on_graphics));
+}
+
+void VidPlayerListenerProxy::PlaybackPositionUpdatedCallback(
+    int64_t  current_time,
+    const VidPlayerDecodeStatistics &decode_stats) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&WebMediaPlayerBrightsign::PlaybackPositionUpdatedCallback,
+                     web_media_player_, current_time, decode_stats));
+}
+
+void VidPlayerListenerProxy::DurationChangedCallback(
+    int64_t duration) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::DurationChangedCallback,
+                                web_media_player_, duration));
+}
+
+void VidPlayerListenerProxy::ReleasedCallback() {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&WebMediaPlayerBrightsign::ReleasedCallback, web_media_player_));
+}
+
+void VidPlayerListenerProxy::PausedCallback() {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&WebMediaPlayerBrightsign::PausedCallback, web_media_player_));
+}
+
+void VidPlayerListenerProxy::FrameReadyCallback() {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::FrameReadyCallback,
+                                web_media_player_));
+}
+
+void VidPlayerListenerProxy::SubtitleUpdatedCallback(
+    const StringMapVector& text_tracks) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&WebMediaPlayerBrightsign::SubtitleUpdatedCallback,
+                                web_media_player_, text_tracks));
+}
+
+void VidPlayerListenerProxy::TextureMailboxReadyCallback(
+    const VidPlayerMailboxData& mbox) {
+  BS_DEBUG("%s:%d\n", __PRETTY_FUNCTION__, __LINE__);
+  main_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&WebMediaPlayerBrightsign::TextureMailboxReadyCallback,
+                     web_media_player_, mbox));
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/media/brightsign/video_player_proxy.h b/third_party/blink/renderer/platform/media/brightsign/video_player_proxy.h
new file mode 100644
index 0000000000000..ec11c71e81201
--- /dev/null
+++ b/third_party/blink/renderer/platform/media/brightsign/video_player_proxy.h
@@ -0,0 +1,50 @@
+#ifndef MEDIA_BLINK_VID_PLAYER_PROXY_H
+#define MEDIA_BLINK_VID_PLAYER_PROXY_H
+
+#include <libvid/vid_player_c_bindings.h>
+#include "base/memory/weak_ptr.h"
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace base {
+class SingleThreadTaskRunner;
+class TaskRunner;
+}  // namespace base
+
+namespace blink {
+class WebMediaPlayerBrightsign;
+
+class VidPlayerListenerProxy {
+ public:
+  VidPlayerListenerProxy(
+      base::WeakPtr<WebMediaPlayerBrightsign> web_media_player,
+      blink::WebLocalFrame* frame);
+  VidPlayerListenerProxy(const VidPlayerListenerProxy&) = delete;
+  VidPlayerListenerProxy& operator=(const VidPlayerListenerProxy&) = delete;
+  virtual ~VidPlayerListenerProxy();
+
+  void ErrorCallback(enum VidPlayerErrorCode code, const char *message);
+  void PlaybackStartedCallback();
+  void PlaybackCompletedCallback();
+  void LoadCallback(int64_t duration, const StringMapVector& video_tracks,const StringMapVector& audio_tracks, const StringMapVector& text_tracks);
+  void VideoSizeChangedCallback(uint32_t width, uint32_t height,
+                                                      bool video_on_graphics);
+  void PlaybackPositionUpdatedCallback(int64_t current_time,
+                                                             const VidPlayerDecodeStatistics& stats);
+  void DurationChangedCallback(int64_t current_time);
+  void PausedCallback();
+  void SeekCompletedCallback(int64_t current_time);
+  void ReleasedCallback();
+  void FrameReadyCallback();
+  void SubtitleUpdatedCallback(const StringMapVector& text_tracks);
+  void TextureMailboxReadyCallback(const VidPlayerMailboxData& mbox);
+
+ private:
+  const scoped_refptr<base::SingleThreadTaskRunner> main_task_runner_;
+  base::WeakPtr<WebMediaPlayerBrightsign> web_media_player_;
+};
+}  // namespace blink
+
+#endif
diff --git a/third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.cc b/third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.cc
new file mode 100644
index 0000000000000..7a61499360d27
--- /dev/null
+++ b/third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.cc
@@ -0,0 +1,755 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h"
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/task/thread_pool.h"
+#include "base/time/time.h"
+#include "cc/layers/video_layer.h"
+#include "media/base/bind_to_current_loop.h"
+#include "media/base/media_switches.h"
+#include "media/base/video_frame.h"
+#include "media/renderers/paint_canvas_video_renderer.h"
+#include "third_party/blink/public/platform/web_media_player_client.h"
+#include "third_party/blink/public/platform/web_media_player_source.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/renderer/platform/media/brightsign/video_player_proxy.h"
+#include "third_party/blink/renderer/platform/media/web_media_source_impl.h"
+
+#include "gpu/GLES2/gl2extchromium.h"
+#include "gpu/command_buffer/client/gles2_interface.h"
+
+using media::BindToCurrentLoop;
+namespace blink {
+
+static void VidPlayerErrorCallback(void *context, enum VidPlayerErrorCode code, const char *message)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->ErrorCallback(code, message);
+}
+
+static void VidPlayerPlaybackStartedCallback(void *context)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->PlaybackStartedCallback();
+}
+
+static void VidPlayerPlaybackCompletedCallback(void *context)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->PlaybackCompletedCallback();
+}
+
+static void VidPlayerLoadCallback(void *context, int64_t duration, const StringMapVector& video_tracks,
+                                          const StringMapVector& audio_tracks, const StringMapVector& text_tracks)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->LoadCallback(duration, video_tracks, audio_tracks, text_tracks);
+}
+
+static void VidPlayerVideoSizeChangedCallback(void *context, uint32_t width, uint32_t height,
+                                                      int video_on_graphics)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->VideoSizeChangedCallback(width, height, video_on_graphics);
+}
+
+static void VidPlayerPlaybackPositionUpdatedCallback(void *context, int64_t current_time,
+                                                             const VidPlayerDecodeStatistics& stats)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->PlaybackPositionUpdatedCallback(current_time, stats);
+}
+
+static void VidPlayerDurationChangedCallback(void *context, int64_t current_time)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->DurationChangedCallback(current_time);
+}
+
+static void VidPlayerPausedCallback(void *context)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->PausedCallback();
+}
+
+static void VidPlayerSeekCompletedCallback(void *context, int64_t current_time)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->SeekCompletedCallback(current_time);
+}
+
+static void VidPlayerReleasedCallback(void *context)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->ReleasedCallback();
+}
+
+static void VidPlayerFrameReadyCallback(void *context)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->FrameReadyCallback();
+}
+
+static void VidPlayerSubtitleUpdatedCallback(void *context, const StringMapVector& text_tracks)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->SubtitleUpdatedCallback(text_tracks);
+}
+
+static void VidPlayerTextureMailboxReadyCallback(void *context, const VidPlayerMailboxData& mbox)
+{
+    VidPlayerListenerProxy* vid_player_listener = static_cast<VidPlayerListenerProxy*>(context);
+    vid_player_listener->TextureMailboxReadyCallback(mbox);
+}
+
+WebMediaPlayerBrightsign::WebMediaPlayerBrightsign(
+    blink::WebLocalFrame* frame,
+    blink::WebMediaPlayerClient* client,
+    scoped_refptr<base::SequencedTaskRunner> media_task_runner,
+    scoped_refptr<base::SingleThreadTaskRunner> compositor_task_runner,
+    scoped_refptr<base::SingleThreadTaskRunner>
+        video_frame_compositor_task_runner,
+    std::unique_ptr<VideoFrameCompositor> compositor,
+    std::unique_ptr<media::MediaLog> media_log,
+    scoped_refptr<viz::RasterContextProvider> raster_context_provider)
+    : frame_(frame),
+      client_(client),
+      main_task_runner_(frame->GetTaskRunner(TaskType::kMediaElementEvent)),
+      media_task_runner_(std::move(media_task_runner)),
+      compositor_task_runner_(std::move(compositor_task_runner)),
+      vfc_task_runner_(std::move(video_frame_compositor_task_runner)),
+      compositor_(std::move(compositor)),
+      network_state_(WebMediaPlayer::kNetworkStateEmpty),
+      ready_state_(WebMediaPlayer::kReadyStateHaveNothing),
+      highest_ready_state_(WebMediaPlayer::kReadyStateHaveNothing),
+      duration_(std::numeric_limits<double>::quiet_NaN()),
+      current_time_(0.0),
+      latest_time_buffered_(0.0),
+      ended_(false),
+      playing_(false),
+      seeking_(false),
+      video_on_graphics_(false),
+      vid_player_listener_proxy_(
+          new VidPlayerListenerProxy(weak_factory_.GetWeakPtr(), frame_)),
+      video_overlay_factory_(std::make_unique<media::VideoOverlayFactory>()),
+      video_frame_provider_client_(nullptr)
+{
+  vid_player_ = vid_player_create(
+          base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(switches::kVideoServerFactoryName).c_str(),
+          &VidPlayerErrorCallback,
+          &VidPlayerPlaybackStartedCallback,
+          &VidPlayerPlaybackCompletedCallback,
+          &VidPlayerLoadCallback,
+          &VidPlayerVideoSizeChangedCallback,
+          &VidPlayerPlaybackPositionUpdatedCallback,
+          &VidPlayerDurationChangedCallback,
+          &VidPlayerPausedCallback,
+          &VidPlayerSeekCompletedCallback,
+          &VidPlayerReleasedCallback,
+          &VidPlayerFrameReadyCallback,
+          &VidPlayerSubtitleUpdatedCallback,
+          &VidPlayerTextureMailboxReadyCallback,
+          static_cast<void*>(vid_player_listener_proxy_.get()),
+          video_overlay_factory_->overlay_plane_id().ToString().c_str());
+
+
+  weak_this_ = weak_factory_.GetWeakPtr();
+
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+}
+
+WebMediaPlayerBrightsign::~WebMediaPlayerBrightsign() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  frame_ready_timer_.AbandonAndStop();
+  SetVideoFrameProviderClient(NULL);
+  client_->SetCcLayer(nullptr);
+
+  for (const auto& text_track : textTrackMap) {
+    client_->RemoveTextTrack(text_track.second.get());
+  }
+  vid_player_destroy(vid_player_);
+  main_task_runner_->DeleteSoon(FROM_HERE,
+                                std::move(vid_player_listener_proxy_));
+  vfc_task_runner_->DeleteSoon(FROM_HERE, std::move(compositor_));
+}
+
+WebMediaPlayer::LoadTiming WebMediaPlayerBrightsign::Load(
+    LoadType type,
+    const WebMediaPlayerSource& source,
+    CorsMode cors,
+    bool is_cache_disabled) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  std::map<std::string, std::string> attributes;
+  return Load(type, source, cors, attributes);
+}
+
+WebMediaPlayer::LoadTiming WebMediaPlayerBrightsign::Load(
+    LoadType type,
+    const WebMediaPlayerSource& source,
+    CorsMode cors,
+    std::map<std::string, std::string>& attributes) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+
+  current_time_ = 0.0;
+  latest_time_buffered_ = 0.0;
+  playing_ = false;
+  ended_ = false;
+  seeking_ = false;
+  // Non-MSE playback
+  SetNetworkState(WebMediaPlayer::kNetworkStateLoading);
+  SetReadyState(WebMediaPlayer::kReadyStateHaveNothing);
+  blink::WebURL url = source.GetAsURL();
+  GURL representative_url =
+frame_->GetDocument().SiteForCookies().RepresentativeUrl(); std::string
+top_frame_origin = frame_->GetDocument().TopFrameOrigin().ToString().Utf8();
+  StringMap map = {nullptr, 0};
+  vid_player_load(vid_player_, url.GetString().Utf8().c_str(), representative_url.spec().c_str(),
+top_frame_origin.c_str(), map);
+
+  return LoadTiming::kImmediate;
+}
+
+// Playback controls.
+void WebMediaPlayerBrightsign::Play() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  vid_player_play(vid_player_);
+  playing_ = true;
+}
+
+void WebMediaPlayerBrightsign::Pause() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  vid_player_pause(vid_player_);
+  playing_ = false;
+}
+
+void WebMediaPlayerBrightsign::Seek(double seconds) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+
+  vid_player_seek(vid_player_, (uint64_t)(seconds * 1000000));
+
+  ended_ = false;
+  seeking_ = true;
+}
+
+void WebMediaPlayerBrightsign::SetRate(double rate) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  vid_player_set_rate(vid_player_, rate);
+}
+
+void WebMediaPlayerBrightsign::SetVolume(double vol) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  vid_player_set_volume(vid_player_, vol);
+}
+
+void WebMediaPlayerBrightsign::SetLatencyHint(double seconds) {
+  VLOG(1) << __func__ << "(" << seconds << ")";
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+}
+
+void WebMediaPlayerBrightsign::SetPreservesPitch(bool preserves_pitch) {
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+}
+
+void WebMediaPlayerBrightsign::OnRequestPictureInPicture() {}
+
+WebTimeRanges WebMediaPlayerBrightsign::Buffered() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  // Claim to be fully buffered
+  const blink::WebTimeRange buffered_range(0.0, Duration());
+  return WebTimeRanges(&buffered_range, 1);
+}
+
+WebTimeRanges WebMediaPlayerBrightsign::Seekable() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  const blink::WebTimeRange seekable_range(0.0, Duration());
+  return WebTimeRanges(&seekable_range, 1);
+}
+
+// Attempts to switch the audio output device.
+// Implementations of setSinkId take ownership of the WebSetSinkCallbacks
+// object.
+// Note also that setSinkId implementations must make sure that all
+// methods of the WebSetSinkCallbacks object, including constructors and
+// destructors, run in the same thread where the object is created
+// (i.e., the blink thread).
+bool WebMediaPlayerBrightsign::SetSinkId(const WebString& sink_id,
+                                         WebSetSinkIdCompleteCallback) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return true;
+}
+
+// True if the loaded media has a playable video/audio track.
+bool WebMediaPlayerBrightsign::HasVideo() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return true;
+}
+
+bool WebMediaPlayerBrightsign::HasAudio() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return true;
+}
+
+// Dimension of the video.
+gfx::Size WebMediaPlayerBrightsign::NaturalSize() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return natural_size_;
+}
+
+gfx::Size WebMediaPlayerBrightsign::VisibleSize() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return natural_size_;
+}
+
+// Getters of playback state.
+bool WebMediaPlayerBrightsign::Paused() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return ended_ || !playing_;
+}
+
+bool WebMediaPlayerBrightsign::Seeking() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return seeking_;
+}
+
+double WebMediaPlayerBrightsign::Duration() const {
+  VLOG(1) << __func__;
+
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return duration_;
+}
+
+double WebMediaPlayerBrightsign::CurrentTime() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return current_time_;
+}
+
+bool WebMediaPlayerBrightsign::IsEnded() const {
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return ended_;
+}
+
+// Internal states of loading and network.
+WebMediaPlayer::NetworkState WebMediaPlayerBrightsign::GetNetworkState() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return network_state_;
+}
+
+WebMediaPlayer::ReadyState WebMediaPlayerBrightsign::GetReadyState() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return ready_state_;
+}
+
+// Returns an implementation-specific human readable error message, or an
+// empty string if no message is available. The message should begin with a
+// UA-specific-error-code (without any ':'), optionally followed by ': ' and
+// further description of the error.
+WebString WebMediaPlayerBrightsign::GetErrorMessage() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return error_message_;
+}
+
+bool WebMediaPlayerBrightsign::DidLoadingProgress() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return true;
+}
+
+bool WebMediaPlayerBrightsign::WouldTaintOrigin() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return false;
+}
+
+double WebMediaPlayerBrightsign::MediaTimeForTimeValue(double timeValue) const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return base::Seconds(timeValue).InSecondsF();
+}
+
+unsigned WebMediaPlayerBrightsign::DecodedFrameCount() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return decode_stats_.m_DecodedVideoFrames;
+}
+
+unsigned WebMediaPlayerBrightsign::DroppedFrameCount() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return decode_stats_.m_DroppedVideoFrames;
+}
+
+unsigned WebMediaPlayerBrightsign::CorruptedFrameCount() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return decode_stats_.m_CorruptedVideoFrames;
+}
+
+uint64_t WebMediaPlayerBrightsign::AudioDecodedByteCount() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return decode_stats_.m_DecodedAudioBytes;
+}
+
+uint64_t WebMediaPlayerBrightsign::VideoDecodedByteCount() const {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  return decode_stats_.m_DecodedVideoBytes;
+}
+
+bool WebMediaPlayerBrightsign::HasAvailableVideoFrame() const {
+  return current_frame_.get();
+}
+
+void OnReleaseTexture(gpu::Mailbox mbox) {
+}
+
+/*
+void WebMediaPlayerBrightsign::SetAttribute(const std::string& name,
+                                            const std::string& value) {
+  VLOG(1) << __func__;
+  vid_player_->SetAttribute(name, value);
+}
+
+void WebMediaPlayerBrightsign::SetSyncParams(const std::string& domain,
+                                             const std::string& id,
+                                             const std::string& timestamp) {
+  VLOG(1) << __func__;
+  vid_player_->SetSyncParams(domain, id, timestamp);
+}
+*/
+
+void WebMediaPlayerBrightsign::SetNetworkState(
+    WebMediaPlayer::NetworkState state) {
+  VLOG(1) << __func__ << "(" << state << ")";
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  network_state_ = state;
+  // Always notify to ensure client has the latest value.
+  client_->NetworkStateChanged();
+}
+
+void WebMediaPlayerBrightsign::SetReadyState(WebMediaPlayer::ReadyState state) {
+  VLOG(1) << __func__ << "(" << state << ")";
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+
+  if (state == WebMediaPlayer::kReadyStateHaveEnoughData &&
+      network_state_ == WebMediaPlayer::kNetworkStateLoading)
+    SetNetworkState(WebMediaPlayer::kNetworkStateLoaded);
+
+  ready_state_ = state;
+  highest_ready_state_ = std::max(highest_ready_state_, ready_state_);
+
+  // Always notify to ensure client has the latest value.
+  client_->ReadyStateChanged();
+}
+
+void WebMediaPlayerBrightsign::OnEncryptedMediaInitData(
+    media::EmeInitDataType init_data_type,
+    const std::vector<uint8_t>& init_data) {
+}
+
+void WebMediaPlayerBrightsign::OnProgress() {
+
+  // This is called by the demuxer whenever there's some more data available
+}
+
+void WebMediaPlayerBrightsign::ErrorCallback(enum VidPlayerErrorCode code, const char *message) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  error_message_ = blink::WebString::FromUTF8(message);
+
+  if (ready_state_ == WebMediaPlayer::kReadyStateHaveNothing) {
+    // Any error that occurs before reaching ReadyStateHaveMetadata should
+    // be considered a format error.
+    SetNetworkState(WebMediaPlayer::kNetworkStateFormatError);
+  } else {
+    switch (code) {
+      case VID_PLAYER_MEDIA_NETWORK_ERROR:
+        SetNetworkState(WebMediaPlayer::kNetworkStateNetworkError);
+        break;
+      case VID_PLAYER_MEDIA_UNKNOWN_ERROR:
+      case VID_PLAYER_MEDIA_PLAYBACK_ERROR:
+        SetNetworkState(WebMediaPlayer::kNetworkStateDecodeError);
+        break;
+    }
+  }
+}
+
+void WebMediaPlayerBrightsign::PlaybackStartedCallback() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  ended_ = false;
+}
+
+void WebMediaPlayerBrightsign::PlaybackCompletedCallback() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+
+  // If this event arrives after Load has been called, then there's no further
+  // action to take, as Load has already reset current_time_ and playing_
+  if (ready_state_ == kReadyStateHaveNothing) {
+    return;
+  }
+
+  ended_ = true;
+  playing_ = false;
+  if (current_time_ != duration_) {
+    if (duration_ == std::numeric_limits<double>::infinity()) {
+      duration_ = current_time_;
+      client_->DurationChanged();
+    }
+    client_->TimeChanged();
+  }
+}
+
+void WebMediaPlayerBrightsign::SubtitleUpdatedCallback(const StringMapVector& text_tracks) {
+    /*
+  for (auto t : text_tracks) {
+    // We have ownership of the text track objects, so keep them in a map and
+    // just pass pointer in to AddTextTrack
+    std::string id = t["pid"];
+    WebInbandTextTrackImpl::Kind kind = WebInbandTextTrackImpl::kKindSubtitles;
+    if (id == "0") {
+      id = t["label"] + t["service_number"];
+      kind = WebInbandTextTrackImpl::kKindCaptions;
+    }
+
+    std::unordered_map<std::string,
+                       std::unique_ptr<WebInbandTextTrackImpl>>::iterator it;
+
+    it = textTrackMap.find(id);
+    if (it != textTrackMap.end()) {
+      // Nothing to do, as it's already in the map (we should perhaps update it
+      // if the details change)
+      continue;
+    }
+    // New text track
+    std::unique_ptr<WebInbandTextTrackImpl> web_inband_text_track(
+        new WebInbandTextTrackImpl(kind, blink::WebString::FromUTF8(t["label"]),
+                                   blink::WebString::FromUTF8(t["lang"]),
+                                   blink::WebString::FromUTF8(id)));
+    textTrackMap[id] = std::move(web_inband_text_track);
+    client_->AddTextTrack(textTrackMap[id].get());
+  }
+  */
+}
+
+void WebMediaPlayerBrightsign::LoadCallback(
+int64_t duration, const StringMapVector& video_tracks,
+                                          const StringMapVector& audio_tracks, const StringMapVector& text_tracks
+) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  DurationChangedCallback(duration);  // Before we declare HaveMetadata
+
+  // If we don't know the natural size yet, we need to use the default value of
+  // 640x360 until we do
+  if ((natural_size_.height() == 0) && (natural_size_.width() == 0))
+    natural_size_ = gfx::Size(640, 360);
+  SetReadyState(WebMediaPlayer::kReadyStateHaveMetadata);
+  SetReadyState(WebMediaPlayer::kReadyStateHaveEnoughData);
+  SetNetworkState(WebMediaPlayer::kNetworkStateIdle);
+}
+
+void WebMediaPlayerBrightsign::TextureMailboxReadyCallback(
+    const VidPlayerMailboxData& mbox) {}
+
+void WebMediaPlayerBrightsign::SeekCompletedCallback(
+    int64_t current_time) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  seeking_ = false;
+  PlaybackPositionUpdatedCallback(current_time, decode_stats_);
+}
+
+void WebMediaPlayerBrightsign::VideoSizeChangedCallback(uint32_t width,
+                                                  uint32_t height,
+                                                  bool video_on_graphics) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  natural_size_ = gfx::Size(width, height);
+  // Lazily allocate compositing layer.
+  if (!video_layer_) {
+    video_layer_ = cc::VideoLayer::Create(this, media::VIDEO_ROTATION_0);
+    client_->SetCcLayer(video_layer_.get());
+  }
+
+  // Set current frame
+  if (!video_on_graphics) {
+    /*
+  scoped_refptr<media::VideoFrame> frame =
+      video_overlay_factory_->CreateFrame(
+          gfx::Size(width, height),
+          base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
+              switches::kVideoServerFactoryName));
+              */
+    scoped_refptr<media::VideoFrame> frame =
+        video_overlay_factory_->CreateFrame(gfx::Size(width, height));
+    SetCurrentFrame(frame);
+    DidReceiveFrame();
+    StartFrameReadyTimerIfRequired();
+  }
+}
+
+void WebMediaPlayerBrightsign::PlaybackPositionUpdatedCallback(
+    int64_t current_time,
+    const VidPlayerDecodeStatistics& decode_stats) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+
+  // Update our statistics
+  decode_stats_ = decode_stats;
+
+  // If Load has been called, then there's no further action to take
+  if (ready_state_ == kReadyStateHaveNothing) {
+    return;
+  }
+
+  double current_time_d = current_time;
+  if (current_time_ != current_time_d) {
+    current_time_ = current_time_d;
+    client_->TimeChanged();
+  }
+}
+
+void WebMediaPlayerBrightsign::DurationChangedCallback(
+    int64_t duration) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  duration_ = duration;
+  client_->DurationChanged();
+}
+
+void WebMediaPlayerBrightsign::ReleasedCallback() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  playing_ = false;
+  ended_ = false;
+  seeking_ = false;
+  current_time_ = 0.0;
+  latest_time_buffered_ = 0.0;
+  client_->TimeChanged();
+  duration_ = std::numeric_limits<double>::quiet_NaN();
+  client_->DurationChanged();
+  SetReadyState(WebMediaPlayer::kReadyStateHaveNothing);
+  SetNetworkState(WebMediaPlayer::kNetworkStateIdle);
+}
+
+void WebMediaPlayerBrightsign::PausedCallback() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+}
+
+void WebMediaPlayerBrightsign::FrameReadyCallback() {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+}
+
+void WebMediaPlayerBrightsign::StartFrameReadyTimerIfRequired() {
+  // Start frame timer if it is not already running.
+  // It will ask compositor to aim 60fps.
+  // If brightsign compositor is not fast enough, it will
+  // drop frames, but that is ok.
+  if (video_on_graphics_ && !frame_ready_timer_.IsRunning()) {
+    frame_ready_timer_.SetTaskRunner(compositor_task_runner_);
+    frame_ready_timer_.Start(FROM_HERE, base::Microseconds(16666), this,
+                             &WebMediaPlayerBrightsign::DidReceiveFrame);
+  }
+}
+
+void WebMediaPlayerBrightsign::DidReceiveFrame() {
+  // DidReceiveFrame is called on Timer thread.
+  // It is set/changed on render thread and compositor thread(when
+  // render thread is blocked). Avoid changing it when it is
+  // being changed on other threads.
+  base::AutoLock auto_lock(video_frame_provider_client_lock_);
+  if (video_frame_provider_client_)
+    video_frame_provider_client_->DidReceiveFrame();
+}
+
+void WebMediaPlayerBrightsign::SetCurrentFrame(
+    scoped_refptr<media::VideoFrame>& video_frame) {
+  VLOG(1) << __func__;
+  DCHECK(main_task_runner_->BelongsToCurrentThread());
+  base::AutoLock auto_lock(current_frame_lock_);
+  current_frame_ = video_frame;
+}
+
+scoped_refptr<media::VideoFrame>
+WebMediaPlayerBrightsign::GetCurrentFrameThenUpdate() {
+  return GetCurrentFrame();
+}
+
+absl::optional<media::VideoFrame::ID> WebMediaPlayerBrightsign::CurrentFrameId()
+    const {
+  return current_frame_->unique_id();
+}
+
+void WebMediaPlayerBrightsign::SetVideoFrameProviderClient(Client* client) {
+  // This is called from both the main renderer thread and the compositor
+  // thread (when the main thread is blocked).
+  if (video_frame_provider_client_ && video_frame_provider_client_ != client)
+    video_frame_provider_client_->StopUsingProvider();
+  base::AutoLock auto_lock(video_frame_provider_client_lock_);
+  video_frame_provider_client_ = client;
+}
+
+bool WebMediaPlayerBrightsign::UpdateCurrentFrame(
+    base::TimeTicks deadline_min,
+    base::TimeTicks deadline_max) {
+  return true;
+}
+
+bool WebMediaPlayerBrightsign::HasCurrentFrame() {
+  base::AutoLock auto_lock(current_frame_lock_);
+  return current_frame_.get();
+}
+
+scoped_refptr<media::VideoFrame> WebMediaPlayerBrightsign::GetCurrentFrame() {
+  scoped_refptr<media::VideoFrame> video_frame;
+  {
+    base::AutoLock auto_lock(current_frame_lock_);
+    video_frame = current_frame_;
+  }
+
+  return video_frame;
+}
+
+void WebMediaPlayerBrightsign::PutCurrentFrame() {}
+
+base::WeakPtr<blink::WebMediaPlayer> WebMediaPlayerBrightsign::AsWeakPtr() {
+  return weak_this_;
+}
+
+base::TimeDelta WebMediaPlayerBrightsign::GetPreferredRenderInterval() {
+  return base::Microseconds(8000);
+}
+
+void WebMediaPlayerBrightsign::OnContextLost() {}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h b/third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h
new file mode 100644
index 0000000000000..353615d8f67ae
--- /dev/null
+++ b/third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h
@@ -0,0 +1,246 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_MEDIA_BRIGHTSIGN_WEB_MEDIA_PLAYER_BRIGHTSIGN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_MEDIA_BRIGHTSIGN_WEB_MEDIA_PLAYER_BRIGHTSIGN_H_
+
+#include <libbvp/api.h>
+#include <libvid/vid_player_c_bindings.h>
+#include "base/callback.h"
+#include "base/memory/weak_ptr.h"
+#include "base/task/single_thread_task_runner.h"
+#include "cc/layers/video_frame_provider.h"
+#include "components/viz/common/gpu/raster_context_provider.h"
+#include "media/renderers/video_overlay_factory.h"
+#include "third_party/blink/public/platform/media/video_frame_compositor.h"
+#include "third_party/blink/public/platform/web_media_player.h"
+#include "third_party/blink/renderer/platform/media/web_inband_text_track_impl.h"
+
+namespace cc {
+class PaintCanvas;
+class PaintFlags;
+}  // namespace cc
+
+namespace cc {
+class VideoLayer;
+}
+
+namespace blink {
+class WebLocalFrame;
+class WebMediaPlayerClient;
+class VidPlayerListenerProxy;
+
+// An empty WebMediaPlayer used only for tests. This class defines the methods
+// of WebMediaPlayer so that mock WebMediaPlayers don't need to redefine them if
+// they don't care their behavior.
+class WebMediaPlayerBrightsign
+    : public WebMediaPlayer,
+      public base::SupportsWeakPtr<WebMediaPlayerBrightsign>,
+      public cc::VideoFrameProvider {
+ public:
+  ~WebMediaPlayerBrightsign() override;
+  WebMediaPlayerBrightsign(
+      WebLocalFrame* frame,
+      WebMediaPlayerClient* client,
+      scoped_refptr<base::SequencedTaskRunner> media_task_runner,
+      scoped_refptr<base::SingleThreadTaskRunner> compositor_task_runner,
+      scoped_refptr<base::SingleThreadTaskRunner>
+          video_frame_compositor_task_runner,
+      std::unique_ptr<VideoFrameCompositor> compositor,
+      std::unique_ptr<media::MediaLog> media_log,
+      scoped_refptr<viz::RasterContextProvider> raster_context_provider);
+  WebMediaPlayerBrightsign(const WebMediaPlayerBrightsign&) = delete;
+  WebMediaPlayerBrightsign& operator=(const WebMediaPlayerBrightsign&) = delete;
+
+  LoadTiming Load(LoadType,
+                  const blink::WebMediaPlayerSource&,
+                  CorsMode cors_mode,
+                  bool is_cache_disabled) override;
+
+  LoadTiming Load(LoadType,
+                  const blink::WebMediaPlayerSource&,
+                  CorsMode cors_mode,
+                  std::map<std::string, std::string>&);
+
+  // Playback controls.
+  void Play() override;
+  void Pause() override;
+  void Seek(double seconds) override;
+  void SetRate(double) override;
+  void SetVolume(double) override;
+  void SetLatencyHint(double seconds) override;
+  void SetPreservesPitch(bool preserves_pitch) override;
+  void SetWasPlayedWithUserActivation(
+      bool was_played_with_user_activation) override {}
+  void OnRequestPictureInPicture() override;
+
+  blink::WebTimeRanges Buffered() const override;
+  blink::WebTimeRanges Seekable() const override;
+
+  void OnFrozen() override {}
+
+  bool SetSinkId(const blink::WebString& sink_id,
+                 blink::WebSetSinkIdCompleteCallback) override;
+
+  // True if the loaded media has a playable video/audio track.
+  bool HasVideo() const override;
+  bool HasAudio() const override;
+
+  // Dimension of the video.
+  gfx::Size NaturalSize() const override;
+  gfx::Size VisibleSize() const override;
+
+  // Getters of playback state.
+  bool Paused() const override;
+  bool Seeking() const override;
+  double Duration() const override;
+  double CurrentTime() const override;
+  bool IsEnded() const override;
+
+  // Internal states of loading and network.
+  blink::WebMediaPlayer::NetworkState GetNetworkState() const override;
+  blink::WebMediaPlayer::ReadyState GetReadyState() const override;
+
+  // Returns an implementation-specific human readable error message, or an
+  // empty string if no message is available. The message should begin with a
+  // UA-specific-error-code (without any ':'), optionally followed by ': ' and
+  // further description of the error.
+  blink::WebString GetErrorMessage() const override;
+
+  bool DidLoadingProgress() override;
+
+  // Returns true if the response is CORS-cross-origin and so we shouldn't be
+  // allowing media to play through webaudio.
+  // This should be called after the response has arrived.
+  bool WouldTaintOrigin() const override;
+
+  double MediaTimeForTimeValue(double time_value) const override;
+
+  unsigned DecodedFrameCount() const override;
+  unsigned DroppedFrameCount() const override;
+  unsigned CorruptedFrameCount() const override;
+  uint64_t AudioDecodedByteCount() const override;
+  uint64_t VideoDecodedByteCount() const override;
+
+  bool PassedTimingAllowOriginCheck() const override { return true; }
+
+  void SetVolumeMultiplier(double multiplier) override {}
+  void SuspendForFrameClosed() override {}
+
+  bool HasAvailableVideoFrame() const override;
+
+  void Paint(cc::PaintCanvas*, const gfx::Rect&, cc::PaintFlags&) override {}
+
+  scoped_refptr<media::VideoFrame> GetCurrentFrameThenUpdate() override;
+
+  absl::optional<media::VideoFrame::ID> CurrentFrameId() const override;
+
+  //
+  void ErrorCallback(enum VidPlayerErrorCode code, const char *message);
+  void PlaybackStartedCallback();
+  void PlaybackCompletedCallback();
+  void LoadCallback(int64_t duration, const StringMapVector& video_tracks,
+                                          const StringMapVector& audio_tracks, const StringMapVector& text_tracks);
+  void VideoSizeChangedCallback(uint32_t width, uint32_t height,
+                                                      bool video_on_graphics);
+  void PlaybackPositionUpdatedCallback(int64_t current_time,
+                                                             const VidPlayerDecodeStatistics& stats);
+  void DurationChangedCallback(int64_t current_time);
+  void PausedCallback();
+  void SeekCompletedCallback(int64_t current_time);
+  void ReleasedCallback();
+  void FrameReadyCallback();
+  void SubtitleUpdatedCallback(const StringMapVector& text_tracks);
+  void TextureMailboxReadyCallback(const VidPlayerMailboxData& mbox);
+
+  // void SetAttribute(const std::string& name, const std::string& value)
+  // override; void SetSyncParams(const std::string& domain, const std::string&
+  // id, const std::string& timestamp) override;
+
+  void OnProgress();
+  void OnEncryptedMediaInitData(media::EmeInitDataType init_data_type,
+                                const std::vector<uint8_t>& init_data);
+
+  // Being a cc::VideoFrameProvider
+  void SetVideoFrameProviderClient(Client* client) override;
+  bool UpdateCurrentFrame(base::TimeTicks deadline_min,
+                          base::TimeTicks deadline_max) override;
+  bool HasCurrentFrame() override;
+  scoped_refptr<media::VideoFrame> GetCurrentFrame() override;
+  void PutCurrentFrame() override;
+  base::TimeDelta GetPreferredRenderInterval() override;
+  void OnContextLost() override;
+
+  // cc::VideoFrameProvider helper
+  void DidReceiveFrame();
+  void SetCurrentFrame(scoped_refptr<media::VideoFrame>& frame);
+
+  void StartFrameReadyTimerIfRequired();
+
+  base::WeakPtr<blink::WebMediaPlayer> AsWeakPtr() override;
+
+ private:
+  // Helpers that set the network/ready state and notifies the client if
+  // they've changed.
+  void SetNetworkState(blink::WebMediaPlayer::NetworkState state);
+  void SetReadyState(blink::WebMediaPlayer::ReadyState state);
+
+  blink::WebLocalFrame* frame_;
+  blink::WebMediaPlayerClient* client_;
+
+  VidPlayerDecodeStatistics decode_stats_;
+
+  // Task runner for posting tasks on Chrome's main thread. Also used
+  // for DCHECKs so methods calls won't execute in the wrong thread.
+  const scoped_refptr<base::SingleThreadTaskRunner> main_task_runner_;
+  scoped_refptr<base::SequencedTaskRunner> media_task_runner_;
+
+  // To post messages to compositor
+  const scoped_refptr<base::SingleThreadTaskRunner> compositor_task_runner_;
+  scoped_refptr<base::SingleThreadTaskRunner> vfc_task_runner_;
+  std::unique_ptr<VideoFrameCompositor>
+      compositor_;  // Deleted on |vfc_task_runner_|.
+
+  blink::WebMediaPlayer::NetworkState network_state_;
+  blink::WebMediaPlayer::ReadyState ready_state_;
+  blink::WebMediaPlayer::ReadyState highest_ready_state_;
+  gfx::Size natural_size_;
+  double duration_;
+  double current_time_;
+  double latest_time_buffered_;
+  bool ended_;
+  bool playing_;
+  bool seeking_;
+  bool video_on_graphics_;
+  blink::WebString error_message_;
+
+  base::Lock video_frame_provider_client_lock_;
+  base::RepeatingTimer frame_ready_timer_;
+
+  std::unordered_map<std::string, std::unique_ptr<WebInbandTextTrackImpl>>
+      textTrackMap;
+
+  // The compositor layer for displaying the video content when using composited
+  // playback
+  scoped_refptr<cc::VideoLayer> video_layer_;
+
+  // The video frame object used for rendering by the compositor.
+  scoped_refptr<media::VideoFrame> current_frame_;
+  base::Lock current_frame_lock_;
+
+  std::string url_;
+  std::map<std::string, std::string> attributes_;
+
+  base::WeakPtr<WebMediaPlayerBrightsign> weak_this_;
+  base::WeakPtrFactory<WebMediaPlayerBrightsign> weak_factory_{this};
+  std::unique_ptr<VidPlayerListenerProxy>
+      vid_player_listener_proxy_;
+  std::unique_ptr<media::VideoOverlayFactory> video_overlay_factory_;
+  VidPlayerWrapper* vid_player_;
+  cc::VideoFrameProvider::Client* video_frame_provider_client_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_MEDIA_BRIGHTSIGN_WEB_MEDIA_PLAYER_BRIGHTSIGN_H_
diff --git a/third_party/blink/renderer/platform/media/web_media_player_builder.cc b/third_party/blink/renderer/platform/media/web_media_player_builder.cc
index 7499445be269f..248faef330b62 100644
--- a/third_party/blink/renderer/platform/media/web_media_player_builder.cc
+++ b/third_party/blink/renderer/platform/media/web_media_player_builder.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/task_runner.h"
 #include "components/viz/common/gpu/raster_context_provider.h"
@@ -13,6 +14,7 @@
 #include "media/base/demuxer.h"
 #include "media/base/media_log.h"
 #include "media/base/media_observer.h"
+#include "media/base/media_switches.h"
 #include "media/base/renderer_factory_selector.h"
 #include "media/mojo/mojom/media_metrics_provider.mojom.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
@@ -24,6 +26,9 @@
 #include "third_party/blink/public/platform/web_media_player_client.h"
 #include "third_party/blink/public/platform/web_media_player_encrypted_media_client.h"
 #include "third_party/blink/public/web/web_local_frame.h"
+#if defined(ENABLE_BRIGHTSIGN_MEDIA_PLAYER)
+#include "third_party/blink/renderer/platform/media/brightsign/web_media_player_brightsign.h"
+#endif
 #include "third_party/blink/renderer/platform/media/web_media_player_impl.h"
 
 namespace blink {
@@ -61,21 +66,31 @@ WebMediaPlayer* WebMediaPlayerBuilder::Build(
     bool is_background_video_track_optimization_supported,
     std::unique_ptr<media::Demuxer> demuxer_override,
     scoped_refptr<ThreadSafeBrowserInterfaceBrokerProxy> remote_interfaces) {
-  return new WebMediaPlayerImpl(
-      frame, client, encrypted_client, delegate, std::move(factory_selector),
-      url_index, std::move(compositor), std::move(media_log), player_id,
-      std::move(defer_load_cb), std::move(audio_renderer_sink),
-      std::move(media_task_runner), std::move(worker_task_runner),
-      std::move(compositor_task_runner),
-      std::move(video_frame_compositor_task_runner),
-      std::move(adjust_allocated_memory_cb), initial_cdm,
-      std::move(request_routing_token_cb), std::move(media_observer),
-      enable_instant_source_buffer_gc, embedded_media_experience_enabled,
-      std::move(metrics_provider), std::move(create_bridge_callback),
-      std::move(raster_context_provider), use_surface_layer,
-      is_background_suspend_enabled, is_background_video_playback_enabled,
-      is_background_video_track_optimization_supported,
-      std::move(demuxer_override), std::move(remote_interfaces));
+#if defined(ENABLE_BRIGHTSIGN_MEDIA_PLAYER)
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch(switches::kUseBrightsignMediaPlayer))
+      return new WebMediaPlayerBrightsign(
+              frame, client, std::move(media_task_runner), std::move(compositor_task_runner),
+              std::move(video_frame_compositor_task_runner), std::move(compositor),
+              std::move(media_log), std::move(raster_context_provider));
+  else
+#endif
+      return new WebMediaPlayerImpl(
+          frame, client, encrypted_client, delegate, std::move(factory_selector),
+          url_index, std::move(compositor), std::move(media_log), player_id,
+          std::move(defer_load_cb), std::move(audio_renderer_sink),
+          std::move(media_task_runner), std::move(worker_task_runner),
+          std::move(compositor_task_runner),
+          std::move(video_frame_compositor_task_runner),
+          std::move(adjust_allocated_memory_cb), initial_cdm,
+          std::move(request_routing_token_cb), std::move(media_observer),
+          enable_instant_source_buffer_gc, embedded_media_experience_enabled,
+          std::move(metrics_provider), std::move(create_bridge_callback),
+          std::move(raster_context_provider), use_surface_layer,
+          is_background_suspend_enabled, is_background_video_playback_enabled,
+          is_background_video_track_optimization_supported,
+          std::move(demuxer_override), std::move(remote_interfaces));
 }
 
 }  // namespace blink
-- 
2.30.2

